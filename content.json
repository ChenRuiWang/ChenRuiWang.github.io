{"pages":[],"posts":[{"title":"十个推荐使用的Laravel函数","text":"Laravel中包含各种全局辅助函数。可以使用它们来简化开发流程。在这里，我将编写10个最好用的laravel帮助函，数用于使我的开发更容易。 您必须考虑在必要时使用它们。 您还可以查看中文文档发现更多的辅助函数Laravel help functions array_dot() array_dot() 辅助函数允许你将多维数组转换为使用点符号的一维数组。 12345678$array = [ 'user' =&gt; ['username' =&gt; 'something'], 'app' =&gt; ['creator' =&gt; ['name' =&gt; 'someone'], 'created' =&gt; 'today']];$dot_array = array_dot($array);// [user.username] =&gt; something, [app.creator.name] =&gt; someone, [app.created] =&gt; today array_get() array_get() 函数使用点符号从多维数组中检索值。12345678$array = [ 'user' =&gt; ['username' =&gt; 'something'], 'app' =&gt; ['creator' =&gt; ['name' =&gt; 'someone'], 'created' =&gt; 'today']];$name = array_get($array, 'app.creator.name');// someone 如果key不存在, array_get() 函数还接受可选的第三个参数作为默认值。 123$name = array_get($array, 'app.creator.name', 'anonymous');// anonymous public_path() public_path() 返回 Laravel 应用程序中公共目录的完全限定的绝对路径。 你还可以将路径传递到公共目录中的文件或目录以获取该资源的绝对路径。 它将简单地将 public_path() 添加到你的参数中。 1234$public_path = public_puth();$path = public_path('js/app.js'); Str::orderedUuid() Str::orderedUuid()函数首先生成一个时间戳 uuid。 这个 uuid 可以存储在索引数据库列中。 这些 uuid 是基于时间戳创建的，因此它们会保留你的内容索引。 在 Laravel 5.6 中使用它时，会引发 Ramsey\\Uuid\\Exception\\UnsatisfiedDependencyException。 要解决此问题，只需运行以下命令即可使用 moontoast/math 包： 1composer require &quot;moontoast/math&quot; 12345use Illuminate\\Support\\Str;return (string) Str::orderByUuid()// A timestamp first uuid str_plural() str_plural() 函数将字符串转换为复数形式。该功能只支持英文。 1234567echo str_plural('bank');// banksecho str_plural('developer');// developers route() route() 函数为指定的路由生成路由 URL。 1$url = route('login'); 如果路由接受参数，你可以简单地将它们作为第二个参数传递给一个数组。 1$url = route('products', ['id' =&gt; 1]); 如果你想产生一个相对的 URL 而不是一个绝对的 URL，你可以传递 false 作为第三个参数。 1$url = route('products', ['id' =&gt; 1], false); tap() tap() 函数接受两个参数：一个值和一个闭包。该值将被传递给闭包，然后该值将被返回。闭包返回值无关紧要。1234567$user = App\\User::find(1);return tap($user, function($user) { $user-&gt;update([ 'name' =&gt; 'Random' ]);}); 它不会返回布尔值，而是返回 User Model。 如果你没有传递闭包，你也可以使用 User Model 的任何方法。 无论实际返回的方法如何，返回值都将始终为值。 在下面的例子中，它将返回 User Model 而不是布尔值。 update 方法返回布尔值，但由于用了 tap ，所以它将返回 User Model。 12345$user = App\\User::find(1);return tap($user)-&gt;update([ 'name' =&gt; 'SomeName']); dump() dump() 函数会 dump 给定的变量，同时也支持同时传入多个变量。这对调试非常有用。 12dump($var1);dump($var1, $var2, $var3); str_slug() str_slug() 函数将给定的字符串生成一个 URL 友好的 slug。 你可以使用此功能为帖子或产品标题创建一个 slug。 123$slug = str_slug('Helpers in Laravel', '-');// helpers-in-laravel optional() optional() 函数接受一个参数，你可以调用参数的方法或访问属性。 如果传递的对象为 null，则方法和属性将返回 null，而不是导致错误或抛出异常。 123$user = User::find(1);return optional($user)-&gt;name; 原文地址: https://tutsforweb.com/10-best-laravel-helpers/","link":"/2019/05/06/10-best-laravel-helpers/"},{"title":"PHP实现冒泡排序","text":"冒泡排序 (Bubble Sort)冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。 演示动画: PHP代码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php/** * main * @return void */function main(){ $array = [3, 1, 4, 5, 8, -1, 7, 6, 4, 2, 3]; bubbleSort($array, count($array) - 1); fwrite(STDOUT, \"排序结果: \" . PHP_EOL); foreach ($array as $value) { fwrite(STDOUT, $value . PHP_EOL); }}/** * 冒泡排序 * @param $array * @param $length * @return void */function bubbleSort(array &amp;$array, int $length){ for ($i = 0; $i &lt; $length; ++$i) { for ($j = 0; $j &lt; $length - $i; ++$j) { if ($array[$j] &gt; $array[$j + 1]) { swap($array[$j], $array[$j + 1]); } } }}/** * 交换两个值 * @param mixed $firstVariable * @param mixed $lastVariable * @return void */function swap(&amp;$firstVariable, &amp;$lastVariable){ $temp = $firstVariable; $firstVariable = $lastVariable; $lastVariable = $temp;}main();","link":"/2019/05/07/bubble-sort/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/05/06/hello-world/"},{"title":"PHP实现选择排序","text":"排序算法(Selection Sort)选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。 动画演示： PHP代码实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php/** * main * @return void */function main(){ $array = [3, -1, 4, 5, 8, 7, 9, 6, 4, 2, 3]; selectionSort($array, count($array)); fwrite(STDOUT, \"排序结果： \\n\"); foreach ($array as $value) { fwrite(STDOUT, $value . \"\\n\"); }}/** * 选择排序 * @param array $array * @param int $length * @return void */function selectionSort(array &amp;$array, int $length){ for ($i = 0; $i &lt; $length - 1; $i ++) { // 由于每次都是和最后面的数字进行比较，所以最后一位不需要循环 $min = $i; for ($j = $i + 1; $j &lt; $length; $j ++) { // 循环未排序号的数字 if ($array[$j] &lt; $array[$min]) { $min = $j; } } swap($array[$i], $array[$min]); }}/** * * @param mixed $firstVariable * @param mixed $lastVariable */function swap(&amp;$firstVariable, &amp;$lastVariable){ $temp = $firstVariable; $firstVariable = $lastVariable; $lastVariable = $temp;}main();","link":"/2019/05/10/selection-sort/"}],"tags":[{"name":"Laravel","slug":"Laravel","link":"/tags/Laravel/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"helloworld","slug":"helloworld","link":"/tags/helloworld/"},{"name":"blog","slug":"blog","link":"/tags/blog/"}],"categories":[{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"算法","slug":"算法","link":"/categories/算法/"}]}